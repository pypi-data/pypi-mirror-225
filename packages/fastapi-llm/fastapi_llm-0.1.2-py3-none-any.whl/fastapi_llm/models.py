from datetime import datetime
from .schema import *
from .service import *
from jinja2 import Template
from .ssr import *
previous = """
Conversation:
{{ title }}

Previous messages exchanged with {{ user }}:

{% for message in messages %}
    
    {{ message.role }}:

    {{ message.content }}

{% endfor %}
"""


BucketType = Literal["images", "audio", "video", "assets", "code"]
llm = LLMStack()


class ChatMessage(FaunaModel):
    conversation: str = Field(..., description="The conversation id.", index=True)
    role: Role = Field(..., description="The role of the message.")
    content: str = Field(..., description="The content of the message.")


class Namespace(FaunaModel):
    messages: List[str] = Field(default_factory=list)
    title: str = Field(default="[New Conversation]", index=True)
    user: str = Field(..., index=True)

    @handle_errors
    async def set_title(self, text: str):
        response = await llm.chat(
            text=text,
            context=f"You are a conversation titles generator, you will generate this conversation title based on the  user first prompt. FIRST PROMPT: {text}",
        )
        return await self.update(self.ref, title=response)  # type:ignore

    @handle_errors
    async def chat_with_persistence(
        self, text: str, context: str = "You are a helpful assistant"
    ):
        response = await llm.chat_with_memory(
            text=text, context=context, namespace=self.ref
        )
        user_message = await ChatMessage(
            role="user", content=text, conversation=self.ref  # type:ignore
        ).save()
        assistant_message = await ChatMessage(
            role="assistant", content=response, conversation=self.ref  # type:ignore
        ).save()
        await self.update(
            self.ref,
            messages=self.messages
            + [user_message.ref, assistant_message.ref],  # type:ignore
        )  # type:ignore
        return await ChatMessage.find_many(conversation=self.ref)

    @handle_errors
    async def chat_premium(self, text: str):
        context = Template(previous).render(
            title=self.title,
            user=self.user,
            messages=(await ChatMessage.find_many(limit=4, conversation=self.ref)),
        )
        return await self.chat_with_persistence(text, context)


class User(FaunaModel):
    """
    Auth0 User, Github User or Cognito User
    """

    email: Optional[str] = Field(default=None, index=True)
    email_verified: Optional[bool] = Field(default=False)
    family_name: Optional[str] = Field(default=None)
    given_name: Optional[str] = Field(default=None)
    locale: Optional[str] = Field(default=None, index=True)
    name: str = Field(...)
    nickname: Optional[str] = Field(default=None)
    picture: Optional[str] = Field(default=None)
    sub: str = Field(..., unique=True)
    updated_at: Optional[str] = Field(default=None)


class Upload(FaunaModel):
    """

    S3 Upload Record

    """

    user: str = Field(..., description="User sub", index=True)
    name: str = Field(..., description="File name")
    key: str = Field(..., description="File key", unique=True)
    bucket: BucketType = Field(..., description="File bucket")
    size: int = Field(..., description="File size", gt=0)
    content_type: str = Field(..., description="File type", index=True)
    lastModified: float = Field(
        default_factory=lambda: datetime.now().timestamp(),
        description="Last modified",
        index=True,
    )
    url: Optional[str] = Field(None, description="File url")


class DatabaseKey(FaunaModel):
    """

    Fauna Database Key

    """

    user: str = Field(..., unique=True)
    database: str = Field(...)
    global_id: str = Field(...)
    key: str = Field(...)
    secret: str = Field(...)
    hashed_secret: str = Field(...)
    role: str = Field(...)


class BlogPostWebPage(FaunaModel, FunctionType):
    """
    This function relies on image generation API and content generation API to generate a blog post.
    """

    blog_prompt: str = Field(
        ...,
        description="User input infered from the prompt that describes the main topic of the blogpost",
    )
    image_prompt: str = Field(
        default=...,
        description="User input infered from the prompt that describes the appereance of the image",
    )
    content: Optional[str] = Field(
        default=None,
        description="This content must be generated by the Large Language Model according to the function description",
    )
    image: Optional[str] = Field(
        default=None,
        description="This content must be generated by the Large Language Model according to the function description",
    )
    user: str = Field(..., description="User sub", index=True)
    namespace: str = Field(..., description="File namespace", index=True)

    async def run(self):
        return await self.create_content()

    async def create_content(self):
        prompt_template = f"""
        System:
        You are an SEO expert and master copywriter, while being proficient writing content in Markdown, you goal is to write a comprehensive, creative and engaging blogpost about the following topic:
        {self.blog_prompt}
        You must include the following image as the cover of the blogpost:
        {self.image}
        
        AI:
        """
        self.content = await llm.chat(text=self.blog_prompt, context=prompt_template)
        await self.save()
        return markdown(self.content)
