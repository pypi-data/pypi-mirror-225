# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api.ipynb.

# %% auto 0
__all__ = ['Client']

# %% ../nbs/api.ipynb 3
import requests
import json
from tqdm import tqdm
import os
import time
from urllib import request
import glob
from PIL import Image

# %% ../nbs/api.ipynb 4
class Client:
    "API client"
    def __init__(self):
        pass

    @staticmethod
    def fix_url(url, resized_height):
        url_ = url

        if "/full/full/" in url_:
            if type(resized_height) == int: 
                url_ = url_.replace("/full/full/", f"/full/,{resized_height}/")
            else:
                url_ = url_.replace("/full/full/", f"/full/{resized_height}/")
        
        url = url_

        return url

    @staticmethod
    def downloadImagesFromManifest2(df, output_dir, pos_start=1, pos_end=-1, sleep_time=0, continue_with_error=True, resized_height=1024):
        canvases = df["sequences"][0]["canvases"]

        start = pos_start - 1
        end = pos_end

        urls = []

        for i in tqdm(range(len(canvases))):
            if i >= start and (end < 0 or i < end):
                pass
            else:
                continue

            res = canvases[i]["images"][0]["resource"]
            index = str(i+1).zfill(4)
            path = "{}/{}.jpg".format(output_dir, index)
            os.makedirs(os.path.dirname(path), exist_ok=True)
            url = canvases[i]["images"][0]["resource"]["@id"]

            url = Client.fix_url(url, resized_height)
        

            time.sleep(sleep_time)

            try:
                request.urlretrieve(url, path)
            except Exception as e:
                if continue_with_error:
                    print(e)
                    print("Error: {}".format(url))
                    continue
                else:
                    raise e

            urls.append(url)

        return urls
    
    @staticmethod
    def downloadImagesFromManifest3(df, output_dir, pos_start=1, pos_end=-1, sleep_time=0, continue_with_error=True, resized_height=1024):
        canvases = df["items"]

        start = pos_start - 1
        end = pos_end

        urls = []

        for i in tqdm(range(len(canvases))):
            if i >= start and (end < 0 or i < end):
                pass
            else:
                continue

            res = canvases[i]["items"][0]["items"][0]["body"]
            index = str(i+1).zfill(4)
            path = "{}/{}.jpg".format(output_dir, index)
            os.makedirs(os.path.dirname(path), exist_ok=True)
            url = res["id"]

            
            url = Client.fix_url(url, resized_height)

            time.sleep(sleep_time)

            try:
                request.urlretrieve(url, path)
            except Exception as e:
                if continue_with_error:
                    print(e)
                    print("Error: {}".format(url))
                    continue
                else:
                    raise e

            urls.append(url)

        return urls

    @staticmethod
    def downloadImagesFromManifest(manifest_url, output_dir, pos_start=1, pos_end=-1, sleep_time=0, continue_with_error=True, resized_height=1024):
        # sleep_time = 0

        # start = pos_start - 1
        # end = pos_end

        df = requests.get(manifest_url).json()

        context = df["@context"]

        if context == "http://iiif.io/api/presentation/2/context.json":
            return Client.downloadImagesFromManifest2(df, output_dir, pos_start, pos_end, sleep_time, continue_with_error, resized_height)
        else:
            return Client.downloadImagesFromManifest3(df, output_dir, pos_start, pos_end, sleep_time, continue_with_error, resized_height)
        

        # return urls

    @staticmethod
    def convertBB(bbs):
        x_min = 100000
        y_min = 100000
        x_max = 0
        y_max = 0
        
        for bb in bbs:
            x = bb[0]
            y = bb[1]

            if x < x_min:
                x_min = x
            if x > x_max:
                x_max = x

            if y < y_min:
                y_min = y
            if y > y_max:
                y_max = y
        
        w = x_max - x_min
        h = y_max - y_min

        # return "{},{},{},{}".format(x_min, y_min, w, h)

        return [x_min, y_min, w, h]

    @staticmethod
    def getAnnotations(path, canvas_uri, r=1):
        """
        アノテーションファイルからアノテーションのリストを作成する
        
        Args:  
            path (str): アノテーションファイルのパス  
            canvas_uri (str): 画像のURI  
            r (float, optional): 画像のリサイズ率. Defaults to 1.

        Returns:  
            list: アノテーションのリスト

        """
        df = json.load(open(path, "r"))
        items = []

        for i in range(len(df[0])):
            index = i + 1
            item = df[0][i]

            if "text" not in item:
              text = item[4]
              xywhs = [item[0], item[1], item[2], item[3]]
            else:
              text = item["text"]
              xywhs = Client.convertBB(item["boundingBox"])

            xywh = "{},{},{},{}".format(int(xywhs[0] * r), int(xywhs[1] * r), int(xywhs[2] * r), int(xywhs[3] * r))

            items.append({
                "id": "{}/annos/{}".format(canvas_uri, index),
                "motivation": "commenting",
                "target": "{}#xywh={}".format(canvas_uri, xywh),
                "type": "Annotation",
                "body": {
                    "type": "TextualBody",
                    "value": text
                }
            })

        return items

    @staticmethod
    def createIIIFManifest3(output_path, urls, img_dir, json_path, check_iiif=True, resized_height=1024):
        """マニフェストファイルを作成する
        
        Args:  
            output_path (str): マニフェストファイルの出力先  
            urls (list): 画像のURL  
            img_dir (str): 画像のディレクトリ  
            json_path (str): アノテーションファイルのディレクトリ  
            check_iiif (bool, optional): IIIFのURLかどうかをチェックするかどうか. Defaults to True.  
            resized_height (int, optional): 画像のリサイズ後の高さ. Defaults to 1024.
        """

        json_files = glob.glob(json_path + "/*.json")
        json_files.sort()

        img_files = glob.glob(img_dir + "/*.jpg")
        img_files.sort()

        canvases = []

        for i in range(len(urls)):

            original = urls[i]

            isIIIF = False

            r = 1

            if check_iiif and "/full/" in original and "/0/default" in original:
                isIIIF = True

                info = requests.get(original.split("/full/")[0] + "/info.json").json()
                # o_width = info["width"]
                o_height = info["height"]

                r = o_height / resized_height

            img = Image.open(img_files[i])
            width, height = img.size

            width = int(width * r)
            height = int(height * r)

            # filename = os.path.basename(img_files[i]).split(".")[0]

            body = {
                "format": "image/jpeg",
                "height": height,
                "id": "{}".format(original),
                "type": "Image",
                "width": width
            }

            if isIIIF:
                body["service"] = [{
                    "type": "ImageService2",
                    "id": original.split("/full/")[0],
                    "profile": "level2"
                }]

            canvas = original

            items = [] # アノテーション

            items = Client.getAnnotations(json_files[i], canvas, r)

            page = {
                "annotations" : [
                    {
                        "id" : "{}/annos".format(canvas),
                        "items" : items,
                        "type": "AnnotationPage"
                    }
                ],
                "height": height,
                "id": "{}".format(canvas),
                "items": [
                    {
                        "id": "{}/page".format(canvas),
                        "items": [
                            {
                                "body": body,
                                "id": "{}/page/imageanno".format(canvas),
                                "motivation": "painting",
                                "target": "{}".format(canvas),
                                "type": "Annotation"
                            }
                        ],
                        "type": "AnnotationPage"
                    }
                ],
                "label" : {
                    "none": [
                        "[{}]".format(i+1)
                    ]
                },
                "type": "Canvas",
                "width": width
            }

            canvases.append(page)

        m_data = {
            "@context": [
                "http://iiif.io/api/presentation/3/context.json",
                "http://www.w3.org/ns.anno.jsonld"
            ],
            "id": original,
            "label": {
                "none": [
                    original
                ]
            },
            "behavior": [
                "individuals"
            ],
            "items": canvases,
            "type": "Manifest"
        }

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, 'w') as outfile:
            json.dump(m_data, outfile, ensure_ascii=False, indent=4,)


