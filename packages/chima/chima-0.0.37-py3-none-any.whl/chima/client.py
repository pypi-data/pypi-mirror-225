# This file was auto-generated by Fern from our API Definition.

import json
import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from .core.api_error import ApiError
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_headers import remove_none_from_headers
from .environment import ChimaEnvironment
from .types.ai_response_feedback_response import AiResponseFeedbackResponse
from .types.conversation import Conversation
from .types.conversation_roles import ConversationRoles
from .types.converse_response import ConverseResponse
from .types.customer_context import CustomerContext
from .types.faq_response import FaqResponse
from .types.foundry_filter_response import FoundryFilterResponse
from .types.search_response import SearchResponse
from .types.user_query import UserQuery

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class Chima:
    def __init__(self, *, environment: ChimaEnvironment = ChimaEnvironment.PRODUCTION, token: str):
        self._environment = environment
        self._token = token

    def search(
        self,
        group_id: str,
        *,
        query: str,
        provider: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        pdf: typing.Optional[str] = OMIT,
    ) -> SearchResponse:
        _request: typing.Dict[str, typing.Any] = {"query": query}
        if provider is not OMIT:
            _request["provider"] = provider
        if id is not OMIT:
            _request["id"] = id
        if pdf is not OMIT:
            _request["pdf"] = pdf
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"search/{group_id}"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SearchResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stream(self, *, level_context: str, model_prompt: str) -> typing.Iterator[str]:
        with httpx.stream(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "api_streaming"),
            json=jsonable_encoder({"level_context": level_context, "model_prompt": model_prompt}),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_text():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                return
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def stream_v_2(self, *, level_context: str, model_prompt: typing.List[ConversationRoles]) -> typing.Iterator[str]:
        with httpx.stream(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "api_streaming_v2"),
            json=jsonable_encoder({"level_context": level_context, "model_prompt": model_prompt}),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_text():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                return
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def converse(
        self,
        *,
        user_question: str,
        conversation_history: typing.List[Conversation],
        timestamp: str,
        company_uuid: str,
        company_id: int,
        user_role_id: int,
        conversation_id: typing.Optional[str] = OMIT,
        salesforce_user_id: typing.Optional[str] = OMIT,
        salesforce_name: typing.Optional[str] = OMIT,
    ) -> ConverseResponse:
        _request: typing.Dict[str, typing.Any] = {
            "user_question": user_question,
            "conversation_history": conversation_history,
            "timestamp": timestamp,
            "company_uuid": company_uuid,
            "company_id": company_id,
            "user_role_id": user_role_id,
        }
        if conversation_id is not OMIT:
            _request["conversation_id"] = conversation_id
        if salesforce_user_id is not OMIT:
            _request["salesforce_user_id"] = salesforce_user_id
        if salesforce_name is not OMIT:
            _request["salesforce_name"] = salesforce_name
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "converse"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConverseResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def ai_response_feedback(
        self,
        *,
        company_uuid: str,
        company_id: int,
        user_role_id: int,
        model_context: str,
        rating: int,
        feedback: typing.Optional[str] = OMIT,
        conversation_id: str,
        salesforce_user_id: typing.Optional[str] = OMIT,
        salesforce_name: typing.Optional[str] = OMIT,
    ) -> AiResponseFeedbackResponse:
        _request: typing.Dict[str, typing.Any] = {
            "company_uuid": company_uuid,
            "company_id": company_id,
            "user_role_id": user_role_id,
            "model_context": model_context,
            "rating": rating,
            "conversation_id": conversation_id,
        }
        if feedback is not OMIT:
            _request["feedback"] = feedback
        if salesforce_user_id is not OMIT:
            _request["salesforce_user_id"] = salesforce_user_id
        if salesforce_name is not OMIT:
            _request["salesforce_name"] = salesforce_name
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "ai_response_feedback"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AiResponseFeedbackResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def foundry_filter(
        self,
        *,
        api_key: str,
        company_id: str,
        context: CustomerContext,
        user_query: UserQuery,
        conversation_history: typing.List[ConversationRoles],
    ) -> FoundryFilterResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "foundry_filter"),
            json=jsonable_encoder(
                {
                    "api_key": api_key,
                    "company_id": company_id,
                    "context": context,
                    "user_query": user_query,
                    "conversation_history": conversation_history,
                }
            ),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FoundryFilterResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def faq_model(
        self,
        *,
        api_key: str,
        company_id: str,
        context: CustomerContext,
        user_query: UserQuery,
        conversation_history: typing.List[ConversationRoles],
    ) -> FaqResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "faq_model"),
            json=jsonable_encoder(
                {
                    "api_key": api_key,
                    "company_id": company_id,
                    "context": context,
                    "user_query": user_query,
                    "conversation_history": conversation_history,
                }
            ),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FaqResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def enterprise_stream(self, *, question: str, messages: typing.List[ConversationRoles]) -> typing.Iterator[str]:
        with httpx.stream(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "enterprise_stream"),
            json=jsonable_encoder({"question": question, "messages": messages}),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_text():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                return
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def url_parser(self, *, question: str, messages: typing.List[ConversationRoles]) -> typing.Iterator[str]:
        with httpx.stream(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "url_parser"),
            json=jsonable_encoder({"question": question, "messages": messages}),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_text():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                return
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncChima:
    def __init__(self, *, environment: ChimaEnvironment = ChimaEnvironment.PRODUCTION, token: str):
        self._environment = environment
        self._token = token

    async def search(
        self,
        group_id: str,
        *,
        query: str,
        provider: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        pdf: typing.Optional[str] = OMIT,
    ) -> SearchResponse:
        _request: typing.Dict[str, typing.Any] = {"query": query}
        if provider is not OMIT:
            _request["provider"] = provider
        if id is not OMIT:
            _request["id"] = id
        if pdf is not OMIT:
            _request["pdf"] = pdf
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"search/{group_id}"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SearchResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stream(self, *, level_context: str, model_prompt: str) -> typing.AsyncIterator[str]:
        async with httpx.AsyncClient() as _client:
            async with _client.stream(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "api_streaming"),
                json=jsonable_encoder({"level_context": level_context, "model_prompt": model_prompt}),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            ) as _response:
                if 200 <= _response.status_code < 300:
                    async for _text in _response.aiter_text():
                        if len(_text) == 0:
                            continue
                        yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                    return
                try:
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stream_v_2(
        self, *, level_context: str, model_prompt: typing.List[ConversationRoles]
    ) -> typing.AsyncIterator[str]:
        async with httpx.AsyncClient() as _client:
            async with _client.stream(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "api_streaming_v2"),
                json=jsonable_encoder({"level_context": level_context, "model_prompt": model_prompt}),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            ) as _response:
                if 200 <= _response.status_code < 300:
                    async for _text in _response.aiter_text():
                        if len(_text) == 0:
                            continue
                        yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                    return
                try:
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)

    async def converse(
        self,
        *,
        user_question: str,
        conversation_history: typing.List[Conversation],
        timestamp: str,
        company_uuid: str,
        company_id: int,
        user_role_id: int,
        conversation_id: typing.Optional[str] = OMIT,
        salesforce_user_id: typing.Optional[str] = OMIT,
        salesforce_name: typing.Optional[str] = OMIT,
    ) -> ConverseResponse:
        _request: typing.Dict[str, typing.Any] = {
            "user_question": user_question,
            "conversation_history": conversation_history,
            "timestamp": timestamp,
            "company_uuid": company_uuid,
            "company_id": company_id,
            "user_role_id": user_role_id,
        }
        if conversation_id is not OMIT:
            _request["conversation_id"] = conversation_id
        if salesforce_user_id is not OMIT:
            _request["salesforce_user_id"] = salesforce_user_id
        if salesforce_name is not OMIT:
            _request["salesforce_name"] = salesforce_name
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "converse"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConverseResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def ai_response_feedback(
        self,
        *,
        company_uuid: str,
        company_id: int,
        user_role_id: int,
        model_context: str,
        rating: int,
        feedback: typing.Optional[str] = OMIT,
        conversation_id: str,
        salesforce_user_id: typing.Optional[str] = OMIT,
        salesforce_name: typing.Optional[str] = OMIT,
    ) -> AiResponseFeedbackResponse:
        _request: typing.Dict[str, typing.Any] = {
            "company_uuid": company_uuid,
            "company_id": company_id,
            "user_role_id": user_role_id,
            "model_context": model_context,
            "rating": rating,
            "conversation_id": conversation_id,
        }
        if feedback is not OMIT:
            _request["feedback"] = feedback
        if salesforce_user_id is not OMIT:
            _request["salesforce_user_id"] = salesforce_user_id
        if salesforce_name is not OMIT:
            _request["salesforce_name"] = salesforce_name
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "ai_response_feedback"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AiResponseFeedbackResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def foundry_filter(
        self,
        *,
        api_key: str,
        company_id: str,
        context: CustomerContext,
        user_query: UserQuery,
        conversation_history: typing.List[ConversationRoles],
    ) -> FoundryFilterResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "foundry_filter"),
                json=jsonable_encoder(
                    {
                        "api_key": api_key,
                        "company_id": company_id,
                        "context": context,
                        "user_query": user_query,
                        "conversation_history": conversation_history,
                    }
                ),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FoundryFilterResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def faq_model(
        self,
        *,
        api_key: str,
        company_id: str,
        context: CustomerContext,
        user_query: UserQuery,
        conversation_history: typing.List[ConversationRoles],
    ) -> FaqResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "faq_model"),
                json=jsonable_encoder(
                    {
                        "api_key": api_key,
                        "company_id": company_id,
                        "context": context,
                        "user_query": user_query,
                        "conversation_history": conversation_history,
                    }
                ),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FaqResponse, _response_json)  # type: ignore
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def enterprise_stream(
        self, *, question: str, messages: typing.List[ConversationRoles]
    ) -> typing.AsyncIterator[str]:
        async with httpx.AsyncClient() as _client:
            async with _client.stream(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "enterprise_stream"),
                json=jsonable_encoder({"question": question, "messages": messages}),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            ) as _response:
                if 200 <= _response.status_code < 300:
                    async for _text in _response.aiter_text():
                        if len(_text) == 0:
                            continue
                        yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                    return
                try:
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)

    async def url_parser(self, *, question: str, messages: typing.List[ConversationRoles]) -> typing.AsyncIterator[str]:
        async with httpx.AsyncClient() as _client:
            async with _client.stream(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "url_parser"),
                json=jsonable_encoder({"question": question, "messages": messages}),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            ) as _response:
                if 200 <= _response.status_code < 300:
                    async for _text in _response.aiter_text():
                        if len(_text) == 0:
                            continue
                        yield pydantic.parse_obj_as(str, json.loads(_text))  # type: ignore
                    return
                try:
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)
